<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My Blog</title>
    <link>https://fatjing.github.io/</link>
    <description>Recent content on My Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 01 Apr 2021 19:19:00 +0800</lastBuildDate><atom:link href="https://fatjing.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Use Vim&#39;s Registers to Mimic Killring</title>
      <link>https://fatjing.github.io/posts/vim-registers-killring/</link>
      <pubDate>Thu, 01 Apr 2021 19:19:00 +0800</pubDate>
      
      <guid>https://fatjing.github.io/posts/vim-registers-killring/</guid>
      <description>&lt;p&gt;The so called &amp;lsquo;kill ring&amp;rsquo; is that the content you kill (delete or yank) in an editor will be stored in a stack like place. Later you could cycle through the items in the stack by pressing shortcuts without worrying about losing the text you killed previously.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;re a lot plugins for vim to mimic this behavior, like yankstack.vim, yankring.vim. Unfortunately, these plugins change too much of vim&amp;rsquo;s default behavior and often conflict with many other plugins.&lt;/p&gt;
&lt;p&gt;So I did a little research to see if I could achieve this function with vim&amp;rsquo;s built-in features, and it turns out vim&amp;rsquo;s register could fulfill my need easily.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Iframe Fit to Content</title>
      <link>https://fatjing.github.io/posts/iframe-fit-to-content/</link>
      <pubDate>Thu, 01 Apr 2021 10:27:22 +0800</pubDate>
      
      <guid>https://fatjing.github.io/posts/iframe-fit-to-content/</guid>
      <description>&lt;h4 id=&#34;根据iframe的内容调整其大小&#34;&gt;根据iframe的内容调整其大小&lt;/h4&gt;
&lt;p&gt;在做邮件预览的功能时，需要将邮件的HTML内容显示出来。一开始的做法是sanitized之后直接渲染出来。但是CSS样式要尽量保留，结果就是这些样式连外面不属于邮件的部分也影响了。&lt;/p&gt;
&lt;p&gt;于是把邮件的内容放到一个iframe里面去，隔离它的样式。而iframe一般要写死高度和宽度，这样如果邮件内容过长过宽，就会出现滚动条。理想的情况是根据iframe的内容调整其大小。&lt;/p&gt;
&lt;p&gt;这里记录一下我是怎么做的，直接上代码：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Encapsule Element UI Table</title>
      <link>https://fatjing.github.io/posts/encapsule-element-ui-table/</link>
      <pubDate>Wed, 31 Mar 2021 23:07:45 +0800</pubDate>
      
      <guid>https://fatjing.github.io/posts/encapsule-element-ui-table/</guid>
      <description>&lt;h4 id=&#34;封装element-ui的table&#34;&gt;封装Element-UI的Table&lt;/h4&gt;
&lt;p&gt;在开发后台管理系统时，一个常见的页面布局是：上面一堆过滤搜索条件，下面一个表格显示搜索结果。&lt;/p&gt;
&lt;p&gt;而这个表格通常要满足几点需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表头可以显示图标&lt;/li&gt;
&lt;li&gt;带复选框&lt;/li&gt;
&lt;li&gt;每行行尾有操作按钮如删除、修改&lt;/li&gt;
&lt;li&gt;分页&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在之前的项目里，我直接用Element-UI提供的组件，开发起来比较繁琐。尤其是团队其他人参与进来，每个人实现的风格可能不大一致，后期维护起来也比较痛苦。&lt;/p&gt;
&lt;p&gt;而且新的项目里多了这样一个需求：用户可以配置显示哪些列。也就是说列不是写死的，是动态的。原来的模式不能满足。&lt;/p&gt;
&lt;p&gt;因此在新的项目里我对表格功能进行了封装，这样在使用表格时配置一下Column和数据来源就可以了。而且团队其他人用的风格也一致了。&lt;/p&gt;
&lt;p&gt;下面记录一下我是如何封装的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://fatjing.github.io/about/</link>
      <pubDate>Wed, 31 Mar 2021 22:23:34 +0800</pubDate>
      
      <guid>https://fatjing.github.io/about/</guid>
      <description>My Personal Archive
GitHub</description>
    </item>
    
  </channel>
</rss>
